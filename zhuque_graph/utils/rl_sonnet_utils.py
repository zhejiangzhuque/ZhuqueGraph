from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import sonnet as snt

NUM_LAYERS = 2  # Hard-code number of layers in the edge/node/global models.
LATENT_SIZE = 16  # Hard-code latent layer sizes for demos.

def make_softmax_model():
    return snt.Sequential([
            snt.nets.MLP([64,32,2],activate_final=Ture),
        ])
def make_mlp_model():
  """Instantiates a new MLP, followed by LayerNorm.

  The parameters of each new MLP are not shared with others generated by
  this function.

  Returns:
    A Sonnet module which contains the MLP and LayerNorm.
  """
  return snt.Sequential([
      snt.nets.MLP([LATENT_SIZE] * NUM_LAYERS, activate_final=True),
      snt.LayerNorm()
  ])

def make_edge_model():
  return snt.Sequential([
    snt.nets.MLP([64,32,3],activate_final=True),
#    snt.LayerNorm()
  ])

def make_node_model():
  return snt.Sequential([
    snt.nets.MLP([256],activate_final=True),
    snt.LayerNorm()
  ])

#def make_node_model1():
#  return snt.Sequential([
#    snt.nets.MLP([256],activate_final=False),
#    snt.LayerNorm()
#  ])

def make_Hnode_model():
  return snt.Sequential([
    snt.nets.MLP([64],activate_final=True),
    snt.LayerNorm()
  ])

def make_Lnode_model():
  return snt.Sequential([
    snt.nets.MLP([64,32],activate_final=True),
    snt.LayerNorm()
  ])

def make_conv_model():
  """Instantiates a new MLP, followed by LayerNorm.

  The parameters of each new MLP are not shared with others generated by
  this function.

  Returns:
    A Sonnet module which contains the MLP and LayerNorm.
  """
  return snt.Sequential([
      snt.nets.ConvNet2D(output_channels=[32,32],kernel_shapes=[3,3],strides=[1,1],paddings=['VALID','VALID'],activate_final=True),
      snt.BatchFlatten(),
      
      snt.nets.MLP([256], activate_final=True),
      # snt.nets.MLP([64,32], activate_final=True),
      # snt.nets.MLP([3] , activate_final=False),
      #snt.LayerNorm()
  ])

# def make_conv_model2():
#   return snt.Sequential([
#       snt.nets.ConvNet2D(output_channels=[32,32],kernel_shapes=[3,3],strides=[1,1],paddings=['VALID','VALID'],activate_final=True),
#       snt.BatchFlatten(),
#       snt.nets.MLP([256,128,64,21] , activate_final=False),
#       # snt.LayerNorm()
#   ])

def get_q_model2():
  return snt.Sequential([
    # snt.nets.ConvNet2D(output_channels=[32,32],kernel_shapes=[3,3],strides=[1,1],paddings=['VALID','VALID'],activate_final=True),
    # snt.BatchFlatten(),
    snt.nets.MLP([128,64,13],activate_final=False)
  ])
 
def get_q_model():
  return snt.Sequential([
    # snt.nets.ConvNet2D(output_channels=[32,32],kernel_shapes=[3,3],strides=[1,1],paddings=['VALID','VALID'],activate_final=True),
    # snt.BatchFlatten(),
    snt.nets.MLP([128,64,21],activate_final=False)
  ])